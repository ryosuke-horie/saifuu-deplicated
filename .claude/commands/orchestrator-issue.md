# オーケストレーター Issue

複雑なタスクを順次実行のステップに分割し、各ステップ内で複数の並列サブタスクを含めることができます。
ghコマンドを使用してissue番号から要件を取得します：$ARGUMENTS

## プロセス

1. **初期分析**
   - まず、ghコマンドを使用してタスク全体を分析し、範囲と要件を理解する
   - 依存関係と実行順序を特定する
   - 依存関係に基づいて順次ステップを計画する
   - レビューを受けるためのgitブランチを作成する

2. **ステップ計画**
   - 2-4の順次ステップに分割する
   - 各ステップは複数の並列サブタスクを含むことができる
   - 前のステップからどのコンテキストが必要かを定義する

3. **ステップバイステップ実行**
   - ステップ内の全てのサブタスクを並列で実行する
   - 現在のステップの全サブタスクの完了を待つ
   - 関連する結果を次のステップに渡す
   - 各サブタスクから簡潔な要約（100-200語）を要求する

4. **ステップレビューと適応**
   - 各ステップ完了後、結果をレビューする
   - 残りのステップが依然として適切かを検証する
   - 発見に基づいて次のステップを調整する
   - 必要に応じてサブタスクを追加、削除、または修正する

5. **段階的統合**
   - 完了したステップの結果を統合する
   - 統合された結果を次のステップのコンテキストとして使用する
   - 包括的な理解を段階的に構築する
   - 計画を適応させる柔軟性を維持する

## 使用例

「analyze test lint and commit」が与えられた場合：

**ステップ1：初期分析**（1サブタスク）
- プロジェクト構造を分析してテスト/リント設定を理解する
- gitブランチを作成する

**ステップ2：品質チェック**（並列サブタスク）
- テストを実行して結果を取得する
- リンティングと型チェックを実行する
- gitのステータスと変更を確認する

**ステップ3：問題修正**（並列サブタスク、ステップ2の結果を使用）
- ステップ2で見つかったリンティングエラーを修正する
- ステップ2で見つかった型エラーを修正する
- 変更に基づいてコミットメッセージを準備する
*レビュー：ステップ2でエラーが見つからなかった場合、修正をスキップしてコミットに進む*

**ステップ4：最終検証**（並列サブタスク）
- 修正が機能することを確認するためにテストを再実行する
- 全ての問題が解決されたことを確認するためにリントを再実行する
- 検証済みの変更でコミットを作成する
*レビュー：ステップ3で修正がなかった場合、単純にコミット作成のみに簡素化する*

## 主要な利点

- **順次ロジック**：ステップが順番に実行され、後のステップが前の結果を使用できる
- **並列効率**：各ステップ内で、独立したタスクが同時に実行される
- **メモリ最適化**：各サブタスクが最小限のコンテキストを受け取り、オーバーフローを防ぐ
- **段階的理解**：ステップを通じて知識を段階的に構築する
- **明確な依存関係**：分析 → 実行 → 検証の明示的なフロー

## 実装ノート

- 常に全体の範囲を理解するための単一の分析タスクから始める
- 同じステップ内で関連する並列タスクをグループ化する
- ステップ間では必要最小限の発見のみを渡す（要約、完全な出力ではない）
- 可視性のためにTodoWriteを使用してステップとサブタスクの両方を追跡する
- gitブランチを作成し、プルリクエストを作成してレビューを受ける
- 各ステップ後、明示的に計画を再検討する：
  - 次のステップは依然として関連性があるか？
  - 新しいタスクが必要な何かを発見したか？
  - 今後のステップをスキップまたは簡素化できるか？
  - 新しい検証ステップを追加すべきか？

## 適応計画の例

```
初期計画：ステップ1 → ステップ2 → ステップ3 → ステップ4

ステップ2の後：「テストやリンティングでエラーが見つからなかった」
適応後計画：ステップ1 → ステップ2 → ステップ3をスキップ → 簡素化されたステップ4（コミットのみ）

ステップ2の後：「重要なアーキテクチャの問題が見つかった」
適応後計画：ステップ1 → ステップ2 → 新しいステップ2.5（アーキテクチャ分析） → 修正されたステップ3
